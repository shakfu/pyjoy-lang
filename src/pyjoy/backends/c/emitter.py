"""
pyjoy.backends.c.emitter - Emits C code from converted Joy programs.

This module generates compilable C source code from CProgram representations.
"""

from __future__ import annotations

from pathlib import Path
from textwrap import dedent

from .converter import CDefinition, CProgram, CQuotation, CValue


class CEmitter:
    """
    Emits C code from converted Joy programs.

    Generates standalone C source files that can be compiled with the
    Joy runtime library.
    """

    def __init__(self) -> None:
        self.runtime_dir = Path(__file__).parent / "runtime"
        self._indent_level = 0

    def emit(self, program: CProgram) -> str:
        """
        Emit C code for a complete program.

        Args:
            program: CProgram from the converter

        Returns:
            Complete C source code as a string
        """
        lines: list[str] = []

        # Header
        lines.append(self._emit_header())
        lines.append("")

        # Forward declarations for quotations
        if program.quotations:
            lines.append("/* Forward declarations for quotations */")
            for quot in program.quotations:
                lines.append(f"static JoyQuotation* {quot.name} = NULL;")
            lines.append("")

        # Emit quotation initializers
        if program.quotations:
            lines.append("/* Quotation initialization */")
            lines.append("static void init_quotations(void) {")
            for quot in program.quotations:
                lines.append(self._emit_quotation_init(quot))
            lines.append("}")
            lines.append("")

        # Emit user definitions
        if program.definitions:
            lines.append("/* User-defined words */")
            for defn in program.definitions:
                lines.append(self._emit_definition(defn))
                lines.append("")

        # Emit definition registration
        if program.definitions:
            lines.append("static void register_definitions(JoyContext* ctx) {")
            for defn in program.definitions:
                lines.append(
                    f"    joy_dict_define_primitive("
                    f'ctx->dictionary, "{defn.name}", {defn.c_name});'
                )
            lines.append("}")
            lines.append("")

        # Emit main program execution
        lines.append("/* Main program execution */")
        lines.append("static void run_program(JoyContext* ctx) {")
        if program.main_body:
            lines.append(self._emit_quotation_execution(program.main_body, "    "))
        lines.append("}")
        lines.append("")

        # Emit main function
        lines.append(self._emit_main(program))

        return "\n".join(lines)

    def _emit_header(self) -> str:
        """Emit C file header with includes."""
        return dedent("""\
            /**
             * Joy program compiled to C
             * Generated by pyjoy C backend
             */

            #include <stdio.h>
            #include <stdlib.h>
            #include <string.h>
            #include "joy_runtime.h"
        """)

    def _emit_quotation_init(self, quotation: CQuotation) -> str:
        """Emit code to initialize a quotation variable."""
        lines = []
        lines.append(
            f"    {quotation.name} = joy_quotation_new({len(quotation.terms)});"
        )

        for term in quotation.terms:
            init = self._emit_value_init(term)
            lines.append(f"    joy_quotation_push({quotation.name}, {init});")

        return "\n".join(lines)

    def _emit_value_init(self, value: CValue) -> str:
        """Emit C code to create a JoyValue."""
        if value.type == "integer":
            return f"joy_integer({value.value})"

        elif value.type == "float":
            return f"joy_float({value.value})"

        elif value.type == "boolean":
            return f"joy_boolean({'true' if value.value else 'false'})"

        elif value.type == "char":
            c = value.value
            if c == "\n":
                return "joy_char('\\n')"
            elif c == "\t":
                return "joy_char('\\t')"
            elif c == "\r":
                return "joy_char('\\r')"
            elif c == "\\":
                return "joy_char('\\\\')"
            elif c == "'":
                return "joy_char('\\'')"
            else:
                return f"joy_char('{c}')"

        elif value.type == "string":
            escaped = (
                value.value.replace("\\", "\\\\")
                .replace('"', '\\"')
                .replace("\n", "\\n")
                .replace("\t", "\\t")
            )
            return f'joy_string("{escaped}")'

        elif value.type == "symbol":
            return f'joy_symbol("{value.value}")'

        elif value.type == "set":
            if not value.value:
                return "joy_set_empty()"
            members = ", ".join(str(m) for m in sorted(value.value))
            return f"joy_set_from((int[]){{{members}}}, {len(value.value)})"

        elif value.type == "quotation":
            # Reference the pre-built quotation
            if isinstance(value.value, CQuotation):
                return (
                    f"(JoyValue){{.type = JOY_QUOTATION, "
                    f".data.quotation = joy_quotation_copy({value.value.name})}}"
                )
            else:
                return "joy_quotation_empty()"

        elif value.type == "list":
            if not value.value:
                return "joy_list_empty()"
            # For lists, we need to build them dynamically
            # This is a simplified version - complex lists need special handling
            return "joy_list_empty()"

        else:
            return "/* unknown value */"

    def _emit_definition(self, defn: CDefinition) -> str:
        """Emit a user-defined word as a C function."""
        lines = []
        lines.append(f"static void {defn.c_name}(JoyContext* ctx) {{")
        lines.append(self._emit_quotation_execution(defn.body, "    "))
        lines.append("}")
        return "\n".join(lines)

    def _emit_quotation_execution(
        self, quotation: CQuotation, indent_str: str = ""
    ) -> str:
        """Emit code to execute a quotation inline."""
        lines = []

        for term in quotation.terms:
            if term.type == "symbol":
                # Execute the symbol
                lines.append(f'{indent_str}joy_execute_symbol(ctx, "{term.value}");')

            elif term.type == "quotation":
                # Push the quotation onto the stack
                if isinstance(term.value, CQuotation):
                    qval = (
                        f"(JoyValue){{.type = JOY_QUOTATION, "
                        f".data.quotation = joy_quotation_copy({term.value.name})}}"
                    )
                    lines.append(f"{indent_str}joy_stack_push(ctx->stack, {qval});")
                else:
                    lines.append(f"{indent_str}/* push quotation */")

            else:
                # Push literal value
                init = self._emit_value_init(term)
                lines.append(f"{indent_str}joy_stack_push(ctx->stack, {init});")

        return "\n".join(lines)

    def _emit_main(self, program: CProgram) -> str:
        """Emit the main function."""
        has_quotations = bool(program.quotations)
        has_definitions = bool(program.definitions)

        lines = []
        lines.append("int main(int argc, char* argv[]) {")
        lines.append("    /* Initialize context */")
        lines.append("    JoyContext* ctx = joy_context_new();")
        lines.append("    joy_runtime_init(ctx);")
        lines.append("    joy_set_argv(argc, argv);")
        lines.append("")

        if has_quotations:
            lines.append("    /* Initialize quotations */")
            lines.append("    init_quotations();")
            lines.append("")

        if has_definitions:
            lines.append("    /* Register user definitions */")
            lines.append("    register_definitions(ctx);")
            lines.append("")

        lines.append("    /* Run program */")
        lines.append("    run_program(ctx);")
        lines.append("")
        lines.append("    /* Print final stack */")
        lines.append("    joy_stack_print(ctx->stack);")
        lines.append("")
        lines.append("    /* Cleanup */")
        lines.append("    joy_context_free(ctx);")

        if has_quotations:
            lines.append("")
            lines.append("    /* Free quotations */")
            for quot in program.quotations:
                lines.append(f"    if ({quot.name}) joy_quotation_free({quot.name});")

        lines.append("")
        lines.append("    return 0;")
        lines.append("}")

        return "\n".join(lines)

    def emit_to_file(self, program: CProgram, output_path: str | Path) -> None:
        """
        Emit C code to a file.

        Args:
            program: CProgram from the converter
            output_path: Path to write the C source file
        """
        code = self.emit(program)
        Path(output_path).write_text(code)

    def get_runtime_dir(self) -> Path:
        """Get the path to the runtime directory."""
        return self.runtime_dir
