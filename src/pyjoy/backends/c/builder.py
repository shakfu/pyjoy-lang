"""
pyjoy.backends.c.builder - Builds Joy programs compiled to C.

This module provides functionality to compile C code generated by
the emitter into executable binaries.
"""

from __future__ import annotations

import shutil
import subprocess
from pathlib import Path
from typing import Any


class CBuilder:
    """
    Builds Joy programs compiled to C.

    Handles compilation of generated C code using gcc or clang,
    including the Joy runtime library.
    """

    def __init__(self) -> None:
        self.runtime_dir = Path(__file__).parent / "runtime"
        self.compiler = self._find_compiler()
        self.compile_flags = ["-Wall", "-Wextra", "-std=c11", "-O2"]

    def _find_compiler(self) -> str:
        """Find an available C compiler."""
        for compiler in ["gcc", "clang", "cc"]:
            if shutil.which(compiler):
                return compiler
        raise RuntimeError("No C compiler found. Please install gcc or clang.")

    def get_runtime_sources(self) -> list[Path]:
        """Get the runtime source files."""
        return list(self.runtime_dir.glob("*.c"))

    def get_runtime_headers(self) -> list[Path]:
        """Get the runtime header files."""
        return list(self.runtime_dir.glob("*.h"))

    def compile(
        self,
        source_file: str | Path,
        output_file: str | Path | None = None,
        debug: bool = False,
        optimize: int = 2,
    ) -> Path:
        """
        Compile a Joy C program to an executable.

        Args:
            source_file: Path to the generated C source
            output_file: Path for the output executable (default: source stem)
            debug: Include debug symbols
            optimize: Optimization level (0-3)

        Returns:
            Path to the compiled executable

        Raises:
            RuntimeError: If compilation fails
        """
        source = Path(source_file)
        if not source.exists():
            raise FileNotFoundError(f"Source file not found: {source}")

        if output_file is None:
            output = source.with_suffix("")
        else:
            output = Path(output_file)

        # Build compilation command
        cmd = [self.compiler]

        # Add flags
        cmd.extend(self.compile_flags)

        if debug:
            cmd.append("-g")

        cmd.append(f"-O{optimize}")

        # Add include path for runtime
        cmd.append(f"-I{self.runtime_dir}")

        # Add math library
        cmd.append("-lm")

        # Add runtime sources
        cmd.extend(str(p) for p in self.get_runtime_sources())

        # Add main source
        cmd.append(str(source))

        # Output
        cmd.extend(["-o", str(output)])

        # Run compilation
        result = subprocess.run(cmd, capture_output=True, text=True)

        if result.returncode != 0:
            error_msg = f"Compilation failed:\n{result.stderr}"
            raise RuntimeError(error_msg)

        return output

    def compile_and_run(
        self,
        source_file: str | Path,
        args: list[str] | None = None,
        timeout: float | None = None,
    ) -> subprocess.CompletedProcess[str]:
        """
        Compile and run a Joy C program.

        Args:
            source_file: Path to the generated C source
            args: Command-line arguments for the program
            timeout: Execution timeout in seconds

        Returns:
            CompletedProcess with stdout, stderr, and return code
        """
        executable = self.compile(source_file)

        try:
            cmd = [str(executable)]
            if args:
                cmd.extend(args)

            return subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout,
            )
        finally:
            # Clean up executable
            if executable.exists():
                executable.unlink()

    def generate_makefile(
        self,
        source_file: str | Path,
        target_name: str = "joy_program",
    ) -> str:
        """
        Generate a Makefile for building a Joy C program.

        Args:
            source_file: Path to the generated C source
            target_name: Name of the target executable

        Returns:
            Makefile contents as a string
        """
        source = Path(source_file).name
        runtime_sources = " ".join(p.name for p in self.get_runtime_sources())

        makefile = f"""\
# Makefile for Joy program
# Generated by pyjoy C backend

CC = {self.compiler}
CFLAGS = {" ".join(self.compile_flags)}
LDFLAGS = -lm

RUNTIME_DIR = {self.runtime_dir}
RUNTIME_SRCS = {runtime_sources}

TARGET = {target_name}
SRCS = {source}

.PHONY: all clean

all: $(TARGET)

$(TARGET): $(SRCS) $(RUNTIME_SRCS)
\t$(CC) $(CFLAGS) -I$(RUNTIME_DIR) \\
\t\t$(addprefix $(RUNTIME_DIR)/,$(RUNTIME_SRCS)) $(SRCS) -o $@ $(LDFLAGS)

clean:
\trm -f $(TARGET)

run: $(TARGET)
\t./$(TARGET)
"""
        return makefile

    def save_makefile(
        self,
        output_dir: str | Path,
        source_file: str | Path,
        target_name: str = "joy_program",
    ) -> Path:
        """
        Save a Makefile to a directory.

        Args:
            output_dir: Directory to save the Makefile
            source_file: Path to the generated C source
            target_name: Name of the target executable

        Returns:
            Path to the generated Makefile
        """
        output = Path(output_dir)
        output.mkdir(parents=True, exist_ok=True)

        makefile_path = output / "Makefile"
        makefile_content = self.generate_makefile(source_file, target_name)
        makefile_path.write_text(makefile_content)

        return makefile_path

    def copy_runtime(self, output_dir: str | Path) -> None:
        """
        Copy runtime files to the output directory.

        Args:
            output_dir: Directory to copy runtime files to
        """
        output = Path(output_dir)
        output.mkdir(parents=True, exist_ok=True)

        for src in self.get_runtime_sources():
            dst = output / src.name
            shutil.copy2(src, dst)

        for hdr in self.get_runtime_headers():
            dst = output / hdr.name
            shutil.copy2(hdr, dst)


def compile_joy_to_c(
    source: str,
    output_dir: str | Path | None = None,
    target_name: str = "joy_program",
    compile_executable: bool = True,
    source_path: str | Path | None = None,
) -> dict[str, Any]:
    """
    High-level function to compile Joy source to C.

    Args:
        source: Joy source code
        output_dir: Directory for output files (default: temp directory)
        target_name: Name for the output executable
        compile_executable: Whether to compile the C code
        source_path: Path to the source file (for resolving includes)

    Returns:
        Dictionary with:
            - "c_source": Generated C code
            - "c_file": Path to C file (if output_dir provided)
            - "executable": Path to executable (if compiled)
            - "makefile": Path to Makefile (if output_dir provided)
    """
    from ...parser import Definition
    from .converter import JoyToCConverter
    from .emitter import CEmitter
    from .preprocessor import preprocess_includes

    # Parse and preprocess (expands includes)
    if source_path:
        parse_result = preprocess_includes(source, source_path=source_path)
    else:
        from ...parser import Parser

        parser = Parser()
        parse_result = parser.parse_full(source)

    # Extract definitions from program terms (they're now inlined)
    definitions = {
        t.name: t.body
        for t in parse_result.program.terms
        if isinstance(t, Definition)
    }

    # Convert to C representation
    converter = JoyToCConverter()
    c_program = converter.convert(parse_result.program, definitions)

    # Emit C code
    emitter = CEmitter()
    c_source = emitter.emit(c_program)

    result: dict[str, Any] = {"c_source": c_source}

    if output_dir:
        output = Path(output_dir)
        output.mkdir(parents=True, exist_ok=True)

        # Write C source
        c_file = output / f"{target_name}.c"
        c_file.write_text(c_source)
        result["c_file"] = c_file

        # Build
        builder = CBuilder()

        # Copy runtime
        builder.copy_runtime(output)

        # Generate Makefile
        makefile = builder.save_makefile(output, c_file, target_name)
        result["makefile"] = makefile

        if compile_executable:
            executable = builder.compile(c_file, output / target_name)
            result["executable"] = executable

    return result
